# filter_html.py
from bs4 import BeautifulSoup, NavigableString
import argparse, sys, re
from pathlib import Path

INLINE_TAGS = {"a","b","strong","i","em","span","code","kbd","samp","u","small","sup","sub","mark"}
SKIP_CONTAINERS = {"script","style","noscript","svg","nav","header","footer","aside"}
BREADCRUMB_HINTS = ("sie sind hier", "zu hauptinhalt springen")

def normalize_ws(text: str) -> str:
    return re.sub(r"\s+", " ", text or "").strip()

def only_inline_children(tag) -> bool:
    """True if a block contains only inline tags / text (no block children)."""
    for c in tag.children:
        if isinstance(c, NavigableString):
            continue
        if getattr(c, "name", "").lower() not in INLINE_TAGS:
            return False
    return True

def is_block_heading_anchor(a_tag) -> bool:
    """
    Headline like <div><a>Text</a></div> OR <div><span><a>Text</a></span></div>.
    We check if the *container's* visible text equals the <a>'s text.
    """
    if not a_tag or not a_tag.get_text(strip=True):
        return False
    cont = a_tag
    # climb one level if the immediate parent is an inline wrapper
    if cont.parent and getattr(cont.parent, "name", "").lower() in INLINE_TAGS:
        cont = cont.parent
    parent = cont.parent
    if not parent or getattr(parent, "name", "").lower() not in {"div","td","th"}:
        return False
    parent_txt = normalize_ws(parent.get_text(" ", strip=True))
    link_txt = normalize_ws(a_tag.get_text(" ", strip=True))
    if not parent_txt or not link_txt:
        return False
    # treat as heading when the container text is basically just the link text
    return parent_txt == link_txt and only_inline_children(parent)

def looks_like_breadcrumb(text: str) -> bool:
    lo = (text or "").lower()
    return any(h in lo for h in BREADCRUMB_HINTS)

def filter_html(html: str) -> str:
    soup = BeautifulSoup(html, "html.parser")

    # Remove obvious non-content containers to reduce noise
    for tag in soup.find_all(SKIP_CONTAINERS):
        tag.decompose()

    title = soup.title.get_text(strip=True) if soup.title else ""

    h1 = soup.find("h1")
    h1_text = normalize_ws(h1.get_text(" ", strip=True)) if h1 else ""

    # pick traversal root
    iterable = (h1.find_all_next(True) if h1 else (soup.body or soup).find_all(True))

    lines = []

    # If no <h1>, try to grab a heading immediately before first <pre>
    if not h1:
        pre = soup.find("pre")
        if pre:
            for prev in pre.find_all_previous():
                if prev.name in ("h2","h3","h4","h5","h6","div","td","th","p","b","strong","span"):
                    t = normalize_ws(prev.get_text(" ", strip=True))
                    if t and not looks_like_breadcrumb(t):
                        lines.append(t)
                        break

    for el in iterable:
        name = (el.name or "").lower()

        # Skip obvious crumbs
        if name in {"span","div"}:
            tpeek = normalize_ws(el.get_text(" ", strip=True))
            if looks_like_breadcrumb(tpeek):
                continue

        # Headings h1..h6
        if name in ("h1","h2","h3","h4","h5","h6"):
            txt = normalize_ws(el.get_text(" ", strip=True))

        # Table cells that *act* like headings: <th>â€¦> or <td> with leading <b>/<strong>
        elif name in ("th","td"):
            raw = normalize_ws(el.get_text(" ", strip=True))
            if not raw:
                continue
            if name == "th" or el.find(["b","strong"]):
                txt = raw
            else:
                # not a heading-like cell; ignore
                continue

        # Standalone bold/strong blocks (not inside paragraphs/lis)
        elif name in ("b","strong"):
            if el.find_parent(["p","li"]):
                continue
            txt = normalize_ws(el.get_text(" ", strip=True))

        # Block-level anchor headings (e.g., <div><a>Koordinatensysteme</a></div>)
        elif name == "a" and is_block_heading_anchor(el):
            txt = normalize_ws(el.get_text(" ", strip=True))

        # Headline-ish DIVs that contain only inline nodes (no nested blocks)
        elif name == "div" and only_inline_children(el):
            txt = normalize_ws(el.get_text(" ", strip=True))
            # keep short, meaningful lines; drop UI chrome
            if not txt or looks_like_breadcrumb(txt):
                continue
            # avoid capturing generic top-bar items
            if txt.lower() in {"logout","konto","einstellungen","placeholder","alle dateien"}:
                continue

        # Regular content
        elif name in ("p","li"):
            txt = normalize_ws(el.get_text(" ", strip=True))

        # Preserve formatted blocks
        elif name == "pre":
            txt = el.get_text()  # keep line breaks/spaces

        else:
            continue

        if txt and (not lines or lines[-1] != txt):
            lines.append(txt)

    # assemble output
    out = []
    if title:
        out.append(f"title:{title}")
    if h1_text:
        out.append(h1_text)
    if lines:
        out.append("")
        out.extend(lines)

    return "\n".join(out)

def main():
    ap = argparse.ArgumentParser(description="Filter an HTML/HTM file to plain text.")
    ap.add_argument("input")
    ap.add_argument("-o","--output")
    args = ap.parse_args()

    html = Path(args.input).read_text(encoding="utf-8", errors="ignore")
    result = filter_html(html)

    if args.output:
        Path(args.output).write_text(result + "\n", encoding="utf-8")
    else:
        sys.stdout.write(result + "\n")

if __name__ == "__main__":
    main()
