# filter_html.py
from bs4 import BeautifulSoup, NavigableString, Tag
import argparse, sys, re
from pathlib import Path

INLINE_TAGS = {
    "a","b","strong","i","em","span","code","kbd","samp","u","small",
    "sup","sub","mark","br","img"
}
BLOCKY_FOLLOWS = {"div","table","ul","ol","dl","pre","section","article"}
SKIP_CONTAINERS = {"script","style","noscript","svg","nav","header","footer","aside"}
BREADCRUMB_HINTS = ("sie sind hier", "zu hauptinhalt springen")

UI_CHROME = {
    "logout","konto","einstellungen","placeholder","alle dateien","suche absenden","filter"
}

def normalize_ws(text: str) -> str:
    return re.sub(r"\s+", " ", text or "").strip()

def only_inline_children(tag: Tag) -> bool:
    """True if a block contains only inline tags / text (no block children)."""
    for c in tag.children:
        if isinstance(c, NavigableString):
            if normalize_ws(str(c)) == "":
                continue
            # plain text is fine
            continue
        if getattr(c, "name", "").lower() not in INLINE_TAGS:
            return False
    return True

def is_first_meaningful_child(tag: Tag) -> bool:
    """True if tag is the first non-whitespace child of its parent."""
    if not tag or not tag.parent:
        return False
    for sib in tag.parent.children:
        if isinstance(sib, NavigableString):
            if normalize_ws(str(sib)):
                # visible text before tag -> not first
                return False
            continue
        # first element node encountered
        return sib is tag
    return False

def next_blocky_sibling(tag: Tag) -> bool:
    """True if the next non-whitespace sibling is a block container (table/div/ul/…)."""
    sib = tag.next_sibling
    while isinstance(sib, NavigableString) and not normalize_ws(str(sib)):
        sib = sib.next_sibling
    if isinstance(sib, Tag):
        return sib.name.lower() in BLOCKY_FOLLOWS
    return False

def looks_like_breadcrumb(text: str) -> bool:
    lo = (text or "").lower()
    return any(h in lo for h in BREADCRUMB_HINTS)

def is_block_heading_anchor(a_tag: Tag) -> bool:
    """
    Detect headings implemented as anchors wrapped in a block:
      - <div><a>Text</a></div>               (pure heading container)
      - <div><a>Text</a><table>…</table></div> (heading followed by section)
    """
    if not a_tag or not a_tag.get_text(strip=True):
        return False
    parent = a_tag.parent
    if not parent or getattr(parent, "name", "").lower() not in {"div","td","th"}:
        return False

    link_txt = normalize_ws(a_tag.get_text(" ", strip=True))
    if not link_txt or looks_like_breadcrumb(link_txt) or link_txt.lower() in UI_CHROME:
        return False

    parent_txt = normalize_ws(parent.get_text(" ", strip=True))

    # Case 1: parent text equals the link text and parent contains only inline children
    if parent_txt == link_txt and only_inline_children(parent):
        return True

    # Case 2: anchor is the first child and is immediately followed by a block section
    if is_first_meaningful_child(a_tag) and next_blocky_sibling(a_tag):
        return True

    return False

def filter_html(html: str) -> str:
    soup = BeautifulSoup(html, "html.parser")

    # Remove obvious non-content containers to reduce noise
    for tag in soup.find_all(list(SKIP_CONTAINERS)):
        tag.decompose()

    title = soup.title.get_text(strip=True) if soup.title else ""

    h1 = soup.find("h1")
    h1_text = normalize_ws(h1.get_text(" ", strip=True)) if h1 else ""

    # traversal root
    root = h1 if h1 else (soup.body or soup)
    iterable = root.find_all_next(True) if h1 else root.find_all(True)

    lines = []

    # If no <h1>, try to grab a heading immediately before first <pre>
    if not h1:
        pre = soup.find("pre")
        if pre:
            for prev in pre.find_all_previous():
                if prev.name in ("h2","h3","h4","h5","h6","div","td","th","p","b","strong","span","a"):
                    t = normalize_ws(prev.get_text(" ", strip=True))
                    if t and not looks_like_breadcrumb(t) and t.lower() not in UI_CHROME:
                        lines.append(t)
                        break

    for el in iterable:
        name = (el.name or "").lower()

        # Skip obvious crumbs/utility bars
        if name in {"span","div"}:
            tpeek = normalize_ws(el.get_text(" ", strip=True))
            if looks_like_breadcrumb(tpeek) or tpeek.lower() in UI_CHROME:
                continue

        # Headings h1..h6
        if name in ("h1","h2","h3","h4","h5","h6"):
            txt = normalize_ws(el.get_text(" ", strip=True))

        # Block-level anchor headings
        elif name == "a" and is_block_heading_anchor(el):
            txt = normalize_ws(el.get_text(" ", strip=True))

        # Headline-ish DIVs that contain only inline nodes
        elif name == "div" and only_inline_children(el):
            txt = normalize_ws(el.get_text(" ", strip=True))
            if not txt or looks_like_breadcrumb(txt) or txt.lower() in UI_CHROME:
                continue

        # Table cells that *act* like headings: <th>…> or <td> with leading <b>/<strong>
        elif name in ("th","td"):
            raw = normalize_ws(el.get_text(" ", strip=True))
            if not raw:
                continue
            if name == "th" or el.find(["b","strong"]):
                txt = raw
            else:
                continue

        # Standalone bold/strong blocks (not inside paragraphs/lis)
        elif name in ("b","strong"):
            if el.find_parent(["p","li"]):
                continue
            txt = normalize_ws(el.get_text(" ", strip=True))

        # Regular content
        elif name in ("p","li"):
            txt = normalize_ws(el.get_text(" ", strip=True))

        # Preserve formatted blocks
        elif name == "pre":
            txt = el.get_text()  # keep line breaks/spaces

        else:
            continue

        if txt and (not lines or lines[-1] != txt):
            lines.append(txt)

    # assemble output
    out = []
    if title:
        out.append(f"title:{title}")
    if h1_text:
        out.append(h1_text)
    if lines:
        out.append("")
        out.extend(lines)

    return "\n".join(out)

def main():
    ap = argparse.ArgumentParser(description="Filter an HTML/HTM file to plain text.")
    ap.add_argument("input")
    ap.add_argument("-o","--output")
    args = ap.parse_args()

    html = Path(args.input).read_text(encoding="utf-8", errors="ignore")
    result = filter_html(html)

    if args.output:
        Path(args.output).write_text(result + "\n", encoding="utf-8")
    else:
        sys.stdout.write(result + "\n")

if __name__ == "__main__":
    main()